1) Selección múltiple
Dada la clase:
class A:
x = 1
_y = 2
__z = 3
a = A()

¿Cuáles de los siguientes nombres existen como atributos accesibles directamente desde
a?
A, B son las respuestas correctas ya que se puede acceder a ellas de forma directa.

2) Salida del programa
class A:
  def __init__(self):
    self.__secret = 42
a = A()
print(hasattr(a, '__secret'), hasattr(a, '_A__secret'))

¿Qué imprime?
False True

3) Verdadero/Falso (explica por qué)
a) El prefijo _ impide el acceso desde fuera de la clase. Falso, esto solo indica que está protegido, pero si se puede acceder. 
b) El prefijo __ hace imposible acceder al atributo. Falso, si se puede acceder pero no de forma directa. 
c) El name mangling depende del nombre de la clase. Verdadero, según el nombre de la clase se realiza el name mangling, formando un _clase__atributo.

class Base:
  def __init__(self):
    self._token = "abc"
class Sub(Base):
  def reveal(self):
    return self._token
print(Sub().reveal())

¿Qué se imprime y por qué no hay error de acceso?
imprime "abc" y no hay error de acceso porque _token solo está protegida pero es accesible.

5) Name mangling en herencia

class Base:
  def __init__(self):
    self.__v = 1
class Sub(Base):
  def __init__(self):
    super().__init__()
    self.__v = 2
  def show(self):
    return (self.__v, self._Base__v)
print(Sub().show())

¿Cuál es la salida?
(2, 1)

6) Identifica el error
class Caja:
  __slots__ = ('x',)
c = Caja()
c.x = 10
c.y = 20

¿Qué ocurre y por qué?
En c.y=20 sale un error porque __solts__ restringe los atributos a solo x.

7) Rellenar espacios
Completa para que b tenga un atributo “protegido por convención”.
class B:
  def __init__(self):
    self ______ = 99

Escribe el nombre correcto del atributo.
self._numero = 99

8) Lectura de métodos “privados”
class M:
  def __init__(self):
    self._state = 0
  def _step(self):
    self._state += 1
    return self._state
  def __tick(self):
    return self._step()
m = M()
print(hasattr(m, '_step'), hasattr(m, '__tick'), hasattr(m, '_M__tick'))

¿Qué imprime y por qué?
True False True, porque _step es accesible, __tick está privado y _M__tick está mangled.

9) Acceso a atributos privados
class S:
  def __init__(self):
    self.__data = [1, 2]
  def size(self):
    return len(self.__data)
s = S()
# Accede a __data (solo para comprobar), sin modificar el código de la
clase:
# Escribe una línea que obtenga la lista usando name mangling y la
imprima.

Escribe la línea solicitada.
print(s._S__data)

10) Comprensión de dir y mangling
class D:
  def __init__(self):
    self.__a = 1
    self._b = 2
    self.c = 3
d = D()
names = [n for n in dir(d) if 'a' in n]
print(names)

¿Cuál de estos nombres es más probable que aparezca en la lista: __a, _D__a o a?
Explica.
_D__a,  por que con __a se hace mangling y aparece como _D__a.

11) Completar propiedad con validación
Completa para que saldo nunca sea negativo.
class Cuenta:
  def __init__(self, saldo):
    self._saldo = 0
    self.saldo = saldo
  @property
  def saldo(self):
  @saldo.setter
  def saldo(self, value):
# Validar no-negativo

class Cuenta:
  def __init__(self, saldo):
    self._saldo = 0
    self.saldo = saldo
  @property
  def saldo(self):
    return self._saldo
  @saldo.setter
  def saldo(self, value):
    if value < 0:
      raise ValueError("El saldo no puede ser negativo.")
    self._saldo = value

12) Propiedad de solo lectura
Convierte temperatura_f en un atributo de solo lectura que se calcula desde temperatura_c.
class Termometro:
  def __init__(self, temperatura_c):
    self._c = float(temperatura_c)
# Define aquí la propiedad temperatura_f: F = C * 9/5 + 32

Escribe la propiedad.
class Termometro:
  def __init__(self, temperatura_c):
    self._c = float(temperatura_c)

  @property
  def temperatura_f(self):
    return self._c * 9/5 + 32

13) Invariante con tipo
Haz que nombre sea siempre str. Si asignan algo que no sea str, lanza TypeError.
class Usuario:
  def __init__(self, nombre):
    self.nombre = nombre
# Implementa property para nombre

class Usuario:
  def __init__(self, nombre):
    self.nombre = nombre

  @property
  def nombre(self):
    return self._nombre

  @nombre.setter
  def nombre(self, value):
    if not isinstance(value, str):
      raise TypeError("nombre debe ser str")
    self._nombre = value

14) Encapsulación de colección
Expón una vista de solo lectura de una lista interna.
class Registro:
  def __init__(self):
    self.__items = []
  def add(self, x):
    self.__items.append(x)
# Crea una propiedad 'items' que retorne una tupla inmutable con el contenido
class Registro:
  def __init__(self):
    self.__items = []

  def add(self, x):
    self.__items.append(x)

  @property
  def items(self):
    return tuple(self.__items)

15) Refactor a encapsulación
Refactoriza para evitar acceso directo al atributo y validar que velocidad sea entre 0 y 200.
class Motor:
  def __init__(self, velocidad):
    self.velocidad = velocidad 

Escribe la versión con @property.
class Motor:
  def __init__(self, velocidad):
    self.velocidad = velocidad 

  @property
  def velocidad(self):
    return self._velocidad

  @velocidad.setter
  def velocidad(self, v):
    if not (0 <= v <= 200):
      raise ValueError("La velocidad debe estar entre 0 y 200.")
    self._velocidad = v

16) Elección de convención
Explica con tus palabras cuándo usarías _atributo frente a __atributo en una API pública de una librería.
Usaría _atributo cuando quiero indicar a otras clases o usuarios que el atributo es protegido pero que se permite el acceso en subclases o por retrocompatibilidad.
Usaría __atributo sólo cuando quiera evitar colisiones de nombres en subclases y privatizar la implementación interna. 
Aunque en librerias públicas considero que es factible usar _ para flexibilidad y dar a entender que no es parte de la API.

17) Detección de fuga de encapsulación
¿Qué problema hay aquí?
class Buffer:
  def __init__(self, data):
    self._data = list(data)
  def get_data(self):
    return self._data

Propón una corrección.
class BufferSeguro:
  def __init__(self, data):
    self._data = list(data)

  def get_data(self):
    return tuple(self._data)

18) Diseño con herencia y mangling
¿Dónde fallará esto y cómo lo arreglas?
class A:
  def __init__(self):
    self.__x = 1

class B(A):
  def get(self):
    return self.__x

El código falla porque __x en A se convierte en _A__x, mientras que en B se convierte en _B__x. Por eso B.get() no encuentra el atributo.

Yo lo arreglaría de la siguiente forma:
class A:
  def __init__(self):
    self._x = 1 
class B(A):
  def get(self):
    return self._x
b = B()
print(b.get()) 

19) Composición y fachada
Completa para exponer solo un método seguro de un objeto interno.
class _Repositorio:
  def __init__(self):
    self._datos = {}
  def guardar(self, k, v):
    self._datos[k] = v
  def _dump(self):
    return dict(self._datos)
class Servicio:
  def __init__(self):
    self.__repo = _Repositorio()
# Expón un método 'guardar' que delegue en el repositorio,
# pero NO expongas _dump ni __repo.

class _Repositorio:
  def __init__(self):
    self._datos = {}
  def guardar(self, k, v):
    self._datos[k] = v
  def _dump(self):
    return dict(self._datos)
class Servicio:
  def __init__(self):
    self.__repo = _Repositorio()
  def guardar(self, k, v):
    return self.__repo.guardar(k, v)

20) Mini-kata
Escribe una clase ContadorSeguro con:
• atributo “protegido” _n
• método inc() que suma 1
• propiedad n de solo lectura
• método “privado” __log() que imprima "tick" cuando se incrementa
Muestra un uso básico con dos incrementos y la lectura final.

class ContadorSeguro:
  def __init__(self):
    self._n = 0
  def inc(self):
    self._n += 1
    self.__log()

  @property
  def n(self):
    return self._n
  def __log(self):
    print("tick")
c = ContadorSeguro()
c.inc()   
c.inc()   
print(c.n) 

La lectura final es:
tick
tick
2
